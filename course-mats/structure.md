# Course Structure

This provides a brief overview of the structure and why we are covering the given materials in the respective order for said materials.  The goal is to build to a capable course project at the end of the semester.  As such, we will focus on more foundational knowledge in the first half of the course and then switch over to more sophisticated / complex topics that are important but less critical for a half-semester course project.  

## First Half

* **Week 1 - Introduction and Skill Check**
   * *Lecture 1 - Introduction:* During Week 1, we will begin with the normal introductory materials and course minutia for the course.  As time allows, we will map out what makes an embedded system distinctive and an appropriate mental model for the various acronyms and buzzwords in the space such as IoT, IoE, CPS, SoC, and other key aspects including sensing and actuation. While we will have a bit more of a budget with respect to our computing power for the semester (a Raspberry Pi), a key part that makes an embedded system unique is that we have unique constraints (SWaP-C - size, weight, power, cost) that limit our design space as well as healthy interaction with the physical world meaning that if we mess up, there are real issues potentially beyond just a blue screen or core dump.  
   * *Lecture 2 - Critical Programming:* In our second lecture, we will do a rapid fire review of key concepts for the class including digital logic (finite state machines, bit-wise logic including AND, OR, XOR, NOT), bit-wise manipulation in C, pointers / pointer math in C, and web requests, JSON, and network access in Python. We will come back to several of the topics as relevant for the particular topics but you can think of this lecture as a bit of a level-set making sure that you remember enough from Logic Design, Fundamentals of Computing, and Systems Programming. We will also a very brief recap on `git` as well.
   * *Assignment 1:* Assignment 1 is all about a skill check making sure that you are going to be in good shape for the course.  The basic jist of Assignment 1 involves writing / compiling a network client in C, writing a Python script that both acts as a server as well as a web client, and then passing data back and forth using a library called ZMQ (Zero-Message Queuing) which simplifies much of the normal network minutia. In short, your C code is going to direct your Python code to fetch and process a JSON file from a public web server and then return a C-friendly result. You will be provided example code for getting ZMQ running.  This will also give you a chance to get your *Github* private repository set up and go through the assignment submission mechanics.  
* **Week 2 - Devices, Polling, and Interrupts**
   * In the second week, we are going to look at what it means to access a generic device in the first lecture and then look at how various approaches to interrupts work with respect to both single chip as well as external devices.  It will give us a chance to put to good use what we reviewed in the second lecture with respect to bit-wise manipulation.
   * *Lecture 3 - Devices - Control, Status, Data:* While we will look next week at more simple I/O as accessible via general purpose I/O pins (GPIO), we will focus today on nominal abstractions of devices which can nominally be thought of as having a combination of control, status, and data registers.  Those registers are not registers in the nominal CPU sense but can exist either directly through memory-mapped I/O or in a segmented approach to memory.  Actual RAM / memory will come later but for now, we will want to broaden our perspective on what constitutes memory to a mixture of potentially peripherals / devices as well as traditional RAM.  We will walk through several examples of memory-mapped I/O devices from a few microcontrollers where the devices are included directly on the microcontroller.  
   * *Lecture 4 - Interrupts, Exceptions, Priority:* In the prior lecture, we looked at the generic concept of a device consisting of control, status, and data which lends itself to a polling-style approach allowing the CPU to check and interact with devices.  As the number of devices that we need to interact with scales or the devices themselves tend to have things happen only infrequently, having the CPU actively check can be fairly inefficient. Interrupts allow a device to signal the CPU that it needs service.  We will explore what constitutes an interrupt and how multiple devices can share and / or prioritize various interrupt signaling mechanisms.  We will also aim to understand the concept of the Interrupt Service Routine (ISR) which is often one of the core pieces of functionality associated with a device driver as well as typically being handled by the overarching operating system.
   * *Assignment 2:* In Assignment 2, we will focus on writing lower-level C as well as doing a bit of a deeper dive on binary manipulation. In this assignment, we will be transforming a file through bit-wise manipulation and then recovering that file using the inverse (actually the same) operation. Whereas Assignment 1 was a bit more involved due to getting everything set up correctly, this assignment should be a bit shorter.
* **Week 3 - Digital I/O and Buses**
   * *Lecture 5 - Digital I/O Basics:* - In this lecture, we will look at the basics of digital input and output looking from reading in a basic 1 and 0. We will look at how input comes in such as via mechanical switch or a matrix-style keyboard and the various issues that come in with electro-mechanical inputs (debouncing / etc.).  We will also look at digital output and how we can use that to drive everything from simple LEDs to larger loads through isolation. We will also cover some of the nuance of different digital technology (CMOS, TTL, etc.) and how that impacts translation to a digital 1 or 0 and examine how such information is conveyed in a datasheet.
   * *Lecture 6 - Datasheets, PCBs, and Buses:* We will continue looking at various simple chips and their respective datasheets to help identify several of the common form factors for chips. We will talk about several of the basics associated with Printed Circuit Board (PCB) design as well as various constraints.  We will close out the lecture starting to look at several simple buses and their respective nuances for parallelized I/O including PS/2 and the Centronics printer interface.
* **Week 4 - Clocks and Time-Sensitive I/O**
   * *Lecture 7 - Clocks, Prescalars, Measuring Time:* While digital 1's and 0's can be quite useful when consistently held high or low, bringing in time adds an interesting wrinkle to the mix.  We will look at basic foundations with regards to clocks including how the signal is generated and how said frequencies are impacted by the environment.  We will look at how time gaps can be measured as well as applications such as counting as well as measuring velocity and acceleration (e.g. how anti-lock brakes work).  
   * *Lecture 8 - Time-Driven I/O:* We will continue our focus on time this weeke looking at additional applications that require the measurement of time.  From there, we will pivot to looking at how manipulating high and low signals can be used for precise control via Pulse Width Modulation (PWM) and its application towards stepper motors.  We will look in particular at how this is used for 3-D printing as part of an ongoing exploration of open-source 3D printer code with this class being the first one where we take a look at the code for Lulzbot TAZ 3D printer.
* **Week 5 - A/D and D/As**
   * *Lecture 9 - A/Ds:* With clocks, we started to move away from discrete, single settings for input and output signals and to move into time varying signals.  One challenge for computers is that digital is discrete whereas the world is analog.  In this lecture, we will look at how we bring in and sense the analog world by sampling an analog value (typically voltage, sometimes current) and turning it into a discrete value (e.g. 0 to 255).  We will look at how a device called an A/D works and the various performance constraints that come in as we sense the physical world.  
   * *Lecture 10 - D/As:* The converse of sensing is actuation and as noted in the last lecture, we noted that time and variation are the essence of the real world.  While the time-sensitive I/O from last week operated on a largely triggered basis (e.g. X amount of time has passed), we will look at how we can take our signal encoded via a series of discrete values and then to turn that digital set of values into an analogy signal.  We will also take a look at 3D printers and control exploring the notion of a control loop for the purpose of heating up an extruder nozzle. 
* **Week 6 - Communication - Serial Basics (UART, SPI, I2C) and Wireless**
   * *Project Concept:* Your first part of the course project involves creating a project concept.  This project concept slide deck will be due next Friday (end of Week 7) and will identify your team and the rough area of focus.  We will briefly discss the requirements for this submission in Tuesday's lecture (Lecture 11).
   * *Lecture 11 - Serial Basics (UART, SPI, I2C):* When we consider both A/Ds and D/As and moving data to / from the CPU, on-chip devices are already baked in and we do not need to worry about the difficulty of running various control and data signals across a bus nor necessarily determing how to address the device.  Put simply, running out numerous lines is expensive on a PCB.  An alternative is to use time to allow us to stage bits at a particular cadence (e.g. 9600 bits per second).  In this lecture, we will look at the concept of a serial UART as well as some of the variations that are common (SPI, I2C) allowing us to move and potentially power devices with a minimal number of wires / circuit lines. We will also discuss data encapsulation and the notion of frames as well as a brief discussion on parity / error correction.
   * *Lecture 12 - Wireless:* For most embedded devices, wireless is the primary mechanism by which communications occur with the device.  In this lecture, we will look two of the most common mechanisms for wireless connectivity for embedded devices that fall into the IoT category, Bluetooth and WiFi (802.11).  Bluetooth employs a master / slave type of approach whereby devices will generally pair with one another.  We will briefly discuss a special variant of Bluetooth Low Energy (BLE) called beacons that are only uni-directional (outbound).  We will also cover the basics of WiFi and compare and contrast it versus Bluetooth.   
* **Week 7 - Networking, Cloud**
  * *Lecture 13 - Networking, Cellular:* We will cover several basics of networking including IP, TCP, UDP, DHCP, and NAT looking at how a device in a private LAN gets connected to the Internet.  In particular, we will look at how the overarching transport protocol (TCP, UDP) impacts our data transfers in the event that timeliness is required.  Once we get through our networking basics, we will look at the nuance of cellular as well as comparing and contrasting the how and why on energy consumption and cost across Bluetooth, WiFi, and cellular.  
  * *Lecture 14 - Cloud, Data Storage, Coordination:* In this lecture, we will do a bit of a callback to the very first assignment where we looked at ZMQ.  In that assignment, we used ZMQ to help us bridge between C and Python.  Now, we will think about the broader notion of IoT and how we coordinate and share data with the cloud.  We will look briefly at what makes up the cloud (virtual machines), name / value data stores for the cloud (e.g. Google Firebase), and mechanisms for publish / subscribe communication paradigms for inter-device coordination through MQTT (e.g. Discord for IoT).
* **Week 8 - Mid-Term and Course Projects**
   * *Project Proposal:* The Project proposal will be assigned in class on Thursday and will represent the slide deck turned into a very brief (1-3 page) document describing the focus of the course project, appropriate milestones / deliverables, and estimated components for the embedded system being constructed.   
   * *Lecture 15 - Mid-Term Exam:* The mid-term exam will be an in-class exam that will cover all materials through Lecture 14. The exam will be closed book but you will be allowed four pages of notes (two pages - front / back).  The exam will be a blend of short answer, multiple choice, and at least two programming exercises.  
   * *Lecture 16 - Course Project Proposals:* As part of this lecture, all project teams will present a brief pitch (5 minutes or less) of their course project gathering feedback from the class and instructor.  The feedback will then be provided for the course project proposal that will be due the Friday after break.    